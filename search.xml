<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>快速排序</title>
    <url>/2020/10/02/Quick-Sort-Partition/</url>
    <content><![CDATA[<p>在排序算法中，有多种排序方式，例如比较低级的：冒泡排序、选择排序、插入排序。还有相对高级一些的排序方式，比如说这次要说的快速排序。快速排序相较于三种低级排序的优势在于其时间复杂度较小O (nlogn)，其利用了递归的思想，相较于循环结构，大大缩减了其排序时间，那么，快速排序的思想及原理是什么，下面我们来模拟一下。</p>
<ul>
<li>图一</li>
</ul>
<p><strong><img src="/2020/10/02/Quick-Sort-Partition/1.jpg" class title="图1"></strong><br>以上图为例，在介绍快速排序之前，首先想介绍一种算法，分割法（partition），这种算法实现的目的如下：</p>
<ul>
<li>图二</li>
</ul>
<p><strong><img src="/2020/10/02/Quick-Sort-Partition/2.jpg" class title="图2"></strong><br>分割后的结果如下，可以看出，我们以首部数字作为基准，左侧的数字都比该数字要小，右侧的数字都比它要大，那么我们就可以用一种递归的思想进行排序了，例如说，基于上图，我们再对6的左右两边各进行一下partition函数，是不是就可以得到以下结果：</p>
<ul>
<li>图三</li>
</ul>
<p><strong><img src="/2020/10/02/Quick-Sort-Partition/3.jpg" class title="图3"></strong><br>以此类推，是不是就能得到我们想要排序顺序了，但注意，在本次示例中函数的调用出现了一个问题，后续会给大家解释。<br>说了这么多，那什么是分割法（partition），它的原理思想是什么，下面我们一起看一下：<br>所谓分割法，就是取列表中的一个数，其余的数以它为基准，小于基准数的放于左侧，大于基准数的放于右侧 ，可是放置的方法是什么？下面给大家模拟一下：<br>还是以图一的列表为例，首先我们取首部数字为基准数字，如图一所示，我们取 6 作为基准数字，接下来开始进行模拟，假设我们设有两个指针分别置于左右两端（left，right）：</p>
<ul>
<li>图四</li>
</ul>
<p><strong><img src="/2020/10/02/Quick-Sort-Partition/4.jpg" class title="图4"></strong><br>第一步，我们将首部的数字移开，那么该位置将变成一个空位置：</p>
<ul>
<li>图5</li>
</ul>
<p><strong><img src="/2020/10/02/Quick-Sort-Partition/5.jpg" class title="图5"></strong><br>那么这个时候，left指针指向为空，我们需要从right指针处开始寻找，寻找一个比基准值小的数将它置于现在left指针所指向的空位置。right指针处的数字与基准数进行比较，若小于基准数，则将它置于left指针处，若大于，则right指针进行左移，以此类推，以本文数据为例，从最右侧的 7 进行比较，大于基准数则左移，5 小于6，则 5 填补空缺位置：</p>
<ul>
<li>图六</li>
</ul>
<p><strong><img src="/2020/10/02/Quick-Sort-Partition/6.jpg" class title="图6"></strong><br>现在我们将五填补到了left指针所指的空缺位置，但此时我们会发现，right指针处出现了空缺，这个时候我们千万不要将基准数填补至空缺位置，而是采取和之前一样的办法，反过来，从left指针处开始，寻找比基准数要大的数来填补空缺，应从left指针处开始找，小于则left指针右移，大于则将该位置的数进行填补。由图六所示，从 5 开始，找到 8 ，然后将 8 填补到right指针所指位置，同时将left指针所指位置：</p>
<ul>
<li>图7</li>
</ul>
<p><strong><img src="/2020/10/02/Quick-Sort-Partition/7.jpg" class title="图7"></strong><br>以此类推，left指针空缺，再从right指针开始寻找比基准数小的数填补空缺，反之，right指针处空缺，从left指针处寻找比基准数大的数填补空缺。直到left指针与right指针相遇了，那么将基准数填入此时left指针所指位置，即完成了整个分割过程。</p>
<ul>
<li>图8</li>
</ul>
<p><strong><img src="/2020/10/02/Quick-Sort-Partition/8.jpg" class title="图8"></strong><br>由此，就是我们整个分割算法的实现过程了，接下来就是代码的实现了。代码如下：</p>
<pre><code>  def partition(li,left,right):  #划分  
    tmp = li[left]               #设定tmp的值为基准值
    while left &lt; right:  
        while left &lt; right and li[right] &gt;= tmp:  
            right = right - 1  
        li[left] = li[right]     #若判断发现小于基准数，则将其填补空缺 
        while left &lt; right and li[left] &lt;= tmp:  
            left = left + 1  
        li[right] = li[left]     #若判断发现大于基准数，则将其填补空缺 
    li[left] = tmp               #基准值归位 
    return left                  #返回右指针位置</code></pre>
<p>接下来就是最终的代码实现了，快速排序是递归的过程，上文我们讲过，在基准数左右两边分别进行partition函数即可，首先基于partition函数的返回值，我们可以确定每一次基准数的最终位置，以此为中心，开始左右两边的递归，最终得到顺序结构。</p>
<pre><code>    def _quick_sort(li, left, right):  
      if left &lt; right:             
        mid = partition(li,left,right) #找到每一次的基准数位置  
        _quick_sort(li,left,mid - 1)   #左侧递归
        _quick_sort(li,mid+1,right)    #右侧递归
    def quick_sort(li):                 #简化快排函数的参数
        _quick_sort(li,0,len(li) - 1)</code></pre>
<p>注意：</p>
<ul>
<li>在这种方式的快排过程中，在取首位为基准数时，若首位本身为这个列表的最大值，那么时间复杂度也会随之提高，因此，建议可在选择基准数时进行随机选择，尽可能减少该情况的发生。</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索</title>
    <url>/2020/10/02/Binary-Search/</url>
    <content><![CDATA[<p>计算机算法中有两个大类：搜索、排序。在学习查找算法时，我们首先学习的就是二分搜索，下面就是我对二分搜索的一些理解：<br>二分搜索作为一个基础查找算法，适用于列表中查找数据，其时间复杂度为O(log2n)，但是，该方法有着一个弊端就是需要列表内的数据是按顺序由小到大进行排列的，因此，可参照我的其他文章了解排序算法。<br>二分搜索的原理很简单，对一个有序序列进行搜索，在搜索过程中，先确定左右指针（left，right）每次取中间数（mid）的值与目标值（value）进行比较，若mid值大于目标值（value），则将右指针（right）放与mid指针左边即mid - 1处，反之，若mid值小于目标值（value），则将左指针（left）放与mid指针右边即mid + 1处。最终，若判定到mid指针处的值为目标值（value），则返回此时mid指针位置。</p>
<p>代码如下：</p>
<pre><code>def binary_search(Inp_list,val):  #定义二分搜索函数，两个参数为待搜索列表和目标值
   left = 0  #左指针初始位置为0
   right = len(Inp_list) - 1  #右指针初始位置为最右侧数位置
   while right &gt;= left:  
        mid = (left + right) // 2  #mid指针位置为left与right中间值
        if Inp_list[mid] == val:  
            return mid  
        else:  
            if Inp_list[mid] &gt; val:  
                right = mid - 1  
            else:  
                left = mid + 1</code></pre>
<p>在创建列表时，Python不像C语言那样创建数组，Python中的数组是以列表形式呈现，若手动输入数字需使用Python的列表生成式，代码如下。</p>
<pre><code>list1 = [int(n) for n in input().split()]</code></pre>
<p>最后可进行测试，不要忘记传入参数。<br>注意：</p>
<ul>
<li>1.在Python中，若两数相除取整数位应为‘ // ’，这点与C语言不同。</li>
<li>2.在Python中是没有指针的，文章中所说只是方便理解，请见谅。</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
</search>
