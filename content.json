{"meta":{"title":"RunzeLi's Blog","subtitle":"","description":"一个集百家所长的优质Blog","author":"RunzeLi","url":"https://runze-li.github.io","root":"/"},"pages":[{"title":"404","date":"2020-10-04T11:23:48.575Z","updated":"2020-10-04T11:23:48.568Z","comments":false,"path":"/404.html","permalink":"https://runze-li.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-02T07:20:05.087Z","updated":"2020-10-02T07:20:05.085Z","comments":false,"path":"about/index.html","permalink":"https://runze-li.github.io/about/index.html","excerpt":"","text":"姓名：李润泽 学校： 东北农业大学 主修方向：算法，Python，Java 个人爱好：Linux操作，AI人工智能（Tensor Flow） 联系方式：15045094185"},{"title":"书单","date":"2020-09-30T13:04:17.995Z","updated":"2020-09-30T13:01:41.642Z","comments":false,"path":"books/index.html","permalink":"https://runze-li.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-01T13:04:31.873Z","updated":"2020-09-30T13:01:41.642Z","comments":false,"path":"categories/index.html","permalink":"https://runze-li.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-09-30T13:04:17.996Z","updated":"2020-09-30T13:01:41.642Z","comments":true,"path":"links/index.html","permalink":"https://runze-li.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-09-30T13:04:17.996Z","updated":"2020-09-30T13:01:41.643Z","comments":false,"path":"repository/index.html","permalink":"https://runze-li.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-09-30T13:04:17.996Z","updated":"2020-09-30T13:01:41.643Z","comments":false,"path":"tags/index.html","permalink":"https://runze-li.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"迷宫问题2--浅谈广度优先搜索","slug":"maze-problem-queue","date":"2020-10-07T07:30:07.000Z","updated":"2020-10-08T13:21:24.632Z","comments":true,"path":"2020/10/07/maze-problem-queue/","link":"","permalink":"https://runze-li.github.io/2020/10/07/maze-problem-queue/","excerpt":"","text":"上期文章中，我们通过迷宫问题引入了深度优先搜索，采用了一种利用栈的思想，在本文中，将为大家引入广度优先搜索的思想，利用了一种队列的方式。首先，什么是广度优先搜索？广度优先搜索算法（Breadth-First Search，BFS）是一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。BFS并不使用经验法则算法。那么，广搜与深搜的区别是什么呢？其实很容易区分，深搜可以理解为按照顺序来搜索，譬如说我能走上就绝不走下了，直到没路了再回溯回来尝试向下走，而广搜不同，广搜同时走很多路径，只要能走，就全都一起走，直到有一个点到了终点就终止搜索，接下来，给大家模拟一下使用广度优先搜索的过程，就一目了然了。我们依旧以之前的图说明，先声明一下，图中的数字是走的第几次，也就是到第几步，箭头是说明该点是哪个节点的下一节点，说白了就是两个点之间的引出关系，方便大家的理解。****由图我们可以看出，一个节点可以同时引出不止一个节点，直到最终有点触碰到了终点，则停止继续搜索，其实可以看出，广搜搜索到的路径一定是最短路径。接下来给大家聊一下广搜路径的输出方式，在上文中我们已经了解到，每一个节点都是被其上一节点所引出，找到终点后，其实我们需要对路径进行回推。因此，每一个节点，我们都需要有一个下标作为其地址，方便最后的反向找路。那么就会有人提出问题，如何获得下标，规则是什么？我们假定一个列表（path），用于存取这些坐标，那么我们可以考虑以元组形式进行存储即（横坐标，纵坐标，下标），那么当第一个元素进队后，将其出队存储于我们新创建的path列表中，然后寻找下一个节点，那么下标如何定义，我们举一个简单的例子：****如上图，我们想从 1 走到 7。首先是1 进队列，然后存入path列表中，由于它是首元素，我们给它个下标 -1，我们观察到下一次进队的可以有2和3，那么2和3的下标该怎么给，可以采取这个规则，看是谁让它来的，比如说2和3，是1让他俩来的，那么给他俩的下标就都是 1 的位置 0 ，再往下看，4和5都是由2引进来的，那么他俩的下标就是2这个元素的位置 1，接下来就是7由5引进，7下标是5的位置，以此类推。那么我按照广搜加下标是不是可列出下面的表格：****接下来，我们就可以按这个表格，从7往回找，7按下标找到5，5找到2，2找到1，发现1的下标是-1 则终止。那么如何思路有了，如何进行代码实现呢？首先我们可以调用队列的类库： from collections import deque 然后我们依然用上次的迷宫以及四种移动方式： maze = [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], ] dircs = [ lambda x, y: (x + 1, y), lambda x, y: (x - 1, y), lambda x, y: (x, y + 1), lambda x, y: (x, y - 1), ] 接下来就是主题代码了，首先我们先模拟出输出函数： def print_path(path): headnode = path[-1] # 首先找到存的最后一个位置 real_path = [] # 定义一个新列表存放坐标 while headnode[2] != -1: # 只要下标不为 -1 real_path.append(headnode[0:2]) # 将该坐标放入新列表 headnode = path[headnode[2]] # 新判断位置 real_path.append(headnode[0:2]) # 将起点放入 real_path.reverse() # 倒叙输出 for node in real_path: print(node) 最后就是广搜的部分了： def maze_path_queue(x1, y1, x2, y2): queue = deque() # 定义一个队列 maze[x1][y1] = 2 # 标记起点走过 queue.append((x1, y1, -1)) # 将起点放入队首 path = [] # 定义路径列表 while len(queue) &gt; 0: # 只要队列不为空 headnode = queue.popleft() # 队首出列 path.append(headnode) # 将队首放入路径内 if headnode[0] == x2 and headnode[1] == y2: # 如果发现此时队首是终点则输出 print_path(path) return True for dir in dircs: # 执行移动方法 nextnode = dir(headnode[0], headnode[1]) if maze[nextnode[0]][nextnode[1]] == 0: # 如果下一个点是可走点 queue.append((nextnode[0], nextnode[1], len(path) - 1)) # 下一节点入队并记录下标 # 下标记录谁带它来的 maze[nextnode[0]][nextnode[1]] = 2 # 标记该点已经走过 else: print(&quot;There is no way!&quot;) # 如果队空，则证明没有路 return False 这就是整个迷宫问题的解决方式，大家有哪些不懂的地方可发布在评论区。","categories":[{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/categories/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"迷宫问题--浅谈深度优先搜索","slug":"maze-problem","date":"2020-10-06T13:30:07.000Z","updated":"2020-10-07T07:04:40.029Z","comments":true,"path":"2020/10/06/maze-problem/","link":"","permalink":"https://runze-li.github.io/2020/10/06/maze-problem/","excerpt":"","text":"在数据结构中，我们先学习的是栈和队列，在本文中，我们来简单聊一聊栈。栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。****由上图我们可以看出，栈的底部是封死的，因此栈的特点就是先进后出，后进先出。现在我们来看一道迷宫问题,现在想从上边的红块走到下面的红块，期间，我们需要避开所有的蓝块，且只可以选择 上、下、左、右四个方向来移动，最终请输出每次移动的坐标，若不存在这条道路，就输出没有该路径。****可见上图，为本次的迷宫示意图，为方便大家代码实现，现给出该迷宫的数字表达形式： maze = [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], ] 其中，1 代表不可走的蓝块，0 为可走的白块，（1，1）为起始点，（8，8）为终止点。那么这道题该如何解决呢？首先给大家引入一下深度优先搜索的思想：深度优先搜索属于图算法的一种，是一个针对图和树的遍历算法，英文缩写为DFS即Depth First Search。那么以本题为例，先为大家模拟一下深度优先搜索的过程，以帮助以后更好的理解深度优先搜索。我们首先为这个迷宫设定好坐标：****由上图，我们已经坐标化整个迷宫，现在已知我们只有上、下、左、右这四种移动方式，假定我们按照上下左右的顺序选择了一种方式且可以移动（即下一个块不是蓝块）就不执行其他移动方式（即如果发现上可走，就不要考虑其他移动方式了，上不行就换右）。同时，走过的块我们要将其标记为蓝块，或是其他颜色的块，以区分未走过的白块。现在请根据我以下所写的坐标来看每一步所走的路径：（1，1）-&gt;（2，1）-&gt;（2，2）-&gt;（2，3）-&gt;（3，3）-&gt;（4，3）-&gt;（4，2）-&gt;（4，1）-&gt;（5，1）-&gt;（6，1）-&gt;（6，2）-&gt;（5，2）-&gt;（4，2）。注意，在这个时候我们会发现（4，2）这个点我们之前走过了，那么这个时候，这个点我们就不能再走了，也说明了，这条路径就是不通的，那么怎么办，我们返回上一个点（6，2），去观察他还有没有路能走，只要下一步不是白块，就可以走，因此，我们以此类推，最终退到（2，3）这个点继续模拟：（2，3）-&gt;（1，3）-&gt;（1，2）发现五路可走，那么回退至（1，3）发现可向下走，于是（1，4）-&gt;（1，5）以此类推，直到最终观察能否到达（8，8）。这既是整个过程的一个思路，也是深搜的基本思想，大家可以从整个过程中看出，是不是这个方式运用的是栈的原理，我们永远取的是栈的栈顶元素进行查找，可以就留在栈内，不可以就出栈，查看新一个栈顶元素，下面我们来代码实现一下：首先我们先定义四个移动方式，这里可以使用lambda表达式： dircs = [ lambda x, y: (x + 1, y), lambda x, y: (x - 1, y), lambda x, y: (x, y + 1), lambda x, y: (x, y - 1), ] 接下来就是搜索的过程： def maze_path(x1, y1, x2, y2): stack = [] stack.append((x1, y1)) # 列表中传入的是坐标 while (len(stack) &gt; 0): # 只要栈不为空 topnode = stack[-1] # 当前的栈顶元素 if topnode[0] == x2 and topnode[1] == y2: # 当检测到该点就是终点时输出栈内所有元组 for i in stack: print(i) return True for dir in dircs: # 从四种方向中选取走向 nextnode = dir(topnode[0], topnode[1]) # 查找下一个点的坐标 if maze[nextnode[0]][nextnode[1]] == 0: # 如果该点是白块 stack.append(nextnode) # 这个点入栈 maze[nextnode[0]][nextnode[1]] = 2 # 将该点赋值为2 证明该点已经走过 break else: stack.pop() # 如果没有下一个点，则进行出栈操作 else: print(&quot;There is no way!&quot;) #栈空则证明没有路 return False 这就是一个简单的深搜过程，其实在这个过程中我们只需要注意，走过的点一定要进行标记即可。","categories":[{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/categories/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"Python 队列","slug":"queue","date":"2020-10-06T13:30:07.000Z","updated":"2020-10-08T11:08:53.004Z","comments":true,"path":"2020/10/06/queue/","link":"","permalink":"https://runze-li.github.io/2020/10/06/queue/","excerpt":"","text":"本文将简单阐述一下Python数据结构中队列的原理即实现方式。首先我们来看一下，什么是队列：队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出（First in First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。假设队列是q=（a1,a2,…,an），那么a1就是队头元素，而an是队尾元素。这样我们就可以删除时，总是从a1开始，而插入时，列在最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然在队伍的最后。****如上图所示，队列是一种先进先出的线性表，我们用 front 表示队首，rear 表示队尾，但是在实际的运用过程中，往往会出现一种“假溢出”现象。那么什么是假溢出现象呢？可以理解为系统作为队列用的存储区还没有满,但队列却发生了溢出,我们把这种现象称为”假溢出”。****如上图所示，在队列我的front指针指向的是第一个元素对应的位置，rear指针指向的是最后一个元素所对应的下一个元素位置。****如上图所示，当我一出了a1，a2后，front指针也同时移动到了a3的位置，可是，由于队列只有五个元素的长度，当a5进队列后，rear指针无处可指，同时，我们还发现，队列中还存在着两个位置的空位，这就是这个队列的假溢出现象，那么为了解决这一问题，人们想到了一个新的存储方式—-循环队列。所谓循环队列，就是将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。****如上图所示，就是一个循环队列的基本流程，但是，大家一定也发现了一个问题，为什么我们没有办法判断是否是队满还是队空呢？其实可以根据我们最原始的队列来看，如果front和rear指针相遇在一起，则证明这该队列是空队列，在循环队列中，当最后一个空间存入后，rear后移很容易与front指针再次相遇，因此，我们采取了牺牲一个存储空间的方式，来判断队满和队空。因此哦我们可以得到以下两个计算公式：队列满的条件是： (rear+1)%QueueSize == front 通用的计算队列长度的公式为： (rear - front+ QueueSize)%QueueSize 那么我们要如何实现队列呢，当然可以使用列表，但是本文采用类的方式为大家实现一下队列的原理： class Queue: def __init__(self,size = 100): # 对队列进行初始化操作 self.queue = [0 for i in range(size)] self.size = size self.rear = 0 # 设定头指针和尾指针都为0号元素，此时队空 self.front = 0 def push(self, element): # 定义入队操作 if not self.is_filled(): # 如果队不满 self.rear = (self.rear + 1) % self.size # 队尾指针应指向最后元素的下一地址 self.queue[self.rear] = element # 将该元素放入队列 else: raise IndexError(&quot;Queue is filled.&quot;) # 反之则证明队满，告诉用户不要进了 def pop(self): if not self.is_empty(): # 如果队不空 self.front = (self.front + 1) % self.size # 队首指针指向下一元素 return self.queue[self.front] # 返回队首元素 else: raise IndexError(&quot;Queue is empty.&quot;) # 反之证明队空，则无元素可出 def is_empty(self): # 定义队空，是两指针相等时 return self.rear == self.front def is_filled(self): #定义队满，按照上文公式 return (self.rear + 1) % self.size == self.front 这就是整手写的队列过程。其实，在Python中并不需要这么麻烦，众所周知，Python是一门集百家所长的语言，我们可以import一个对自己有用的类库，譬如说 deque 这个类库。首先进行一波引用： from collections import deque 该类库的特点就是已经帮我们写好了队列的这个类以及其中的成员函数，其中我们主要会用到如下这四个函数： deque.append() # 右侧进队 deque.pop() # 右侧出队 deque.popleft() # 左侧出队 deque.appendleft() # 左侧进队 以上就是Python队列的大致原理及其特有类库，各位看官有何不懂之处，欢迎在评论区留言。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://runze-li.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"数据结构","slug":"数据结构","permalink":"https://runze-li.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"三种基本排序","slug":"low-sort","date":"2020-10-05T13:33:00.000Z","updated":"2020-10-05T13:37:12.365Z","comments":true,"path":"2020/10/05/low-sort/","link":"","permalink":"https://runze-li.github.io/2020/10/05/low-sort/","excerpt":"","text":"以下是三种基础排序的Python实现代码：冒泡排序： def bubble_sort(li): #冒泡排序 for i in range(len(li)-1): for j in range(len(li)-i-1): if li[j] &gt; li[j+1]: li[j],li[j+1] = li[j+1],li[j] 选择排序： def select_sort(li): #选择排序 for i in range(len(li)-1): min_loc = i for j in range (i+1,len(li)): if li[j] &lt; li[min_loc]: min_loc = j li[i],li[min_loc] = li[min_loc],li[i] 插入排序： def insert_sort(li): #插入排序 for i in range(1,len(li)): tmp = li[i] j = i - 1 while j &gt;= 0 and li[j] &gt; tmp: li[j+1] = li[j] j = j - 1 li[j+1] = tmp","categories":[{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"归并排序","slug":"merge-sort","date":"2020-10-04T06:58:21.000Z","updated":"2020-10-04T08:56:46.414Z","comments":true,"path":"2020/10/04/merge-sort/","link":"","permalink":"https://runze-li.github.io/2020/10/04/merge-sort/","excerpt":"","text":"这次要和大家聊一聊归并排序，那么什么是归并排序呢，首先给大家举一个简单的例子：****如上图，我们得到一个列表，其实这个列表有一个规律，那就是如果我们从中间截断，左右两边的小列表其实是有序的，在学习数据结构时，我们学习过一个经典例题，合并两个有序数组，那么这个时候是不是可以像合并数组那样合并这两个有序数列。****如上图，我们把这个列表分为两段，标记好起始元素位置（low）和终止元素位置（high）以及两地址的中间地址（mid），其实，我们已经把整个列表以mid为中心，分成两个小列表了，这个时候就可以利用归并（merge）的思想，首先我们取到两个指针，i，j，这两个指针分别指向两个小列表的第一个元素，这个时候，我们比较i位置的元素大小和j位置的元素大小，我们假设这个列表为lis,那么lis[i] &lt; lis[j]的话，是不是就可以断定，lis[i]此时的元素就是最小的元素了，反之，要是lis[j] &lt; lis[i]，那么lis[j]就是整个列表中最小的元素，这个时候我们就可以把这个最小的元素取出放于一个新列表的首位，我们假设这个新列表是ltmp，这个时候，按照我们的例子，1 就被取下放置于我们的新列表中了，同时，j指针的位置要向后移动一位。****以此类推，比较i位置与j位置的大小关系，然后把每一次的最小值暂存到新列表（ltmp）中，不要忘记指针随着原位置数的取出而后移。****那么什么时候终止呢？有两种情况，第一种是 i 指针大于mid位置的时候，第二种是 j 指针大于high位置的时候。终止后会也会发现两种情况，要么是左边的小列表数字有剩余，要么是右边的小列表数字有剩余，这个时候，我们知道，左右两边的列表其实是有序的，那么本身不需要再进行排列了，直接放到新列表（ltmp）的末尾就好，最后，我们只要把新列表（ltmp）再归还给原列表（lis）就完成了一次归并（merge）。代码如下： def merge(lis,low,mid,high): i = low j = mid + 1 ltmp = [] while i &lt;= mid and j &lt;= high: if lis[i] &lt; lis[j]: ltmp.append(lis[i]) i = i + 1 if lis[j] &lt; lis[i]: ltmp.append(lis[j]) j = j + 1 while i &lt;= mid: ltmp.append(lis[i]) i = i + 1 while j &lt;= high: ltmp.append(lis[j]) j = j + 1 lis[low:high+1] = ltmp 接下来就是整个归并排序的核心了，在实际排序过程中，我们几乎很少能遇到上文这种理想的情况，我们得到的列表大多是无序的。那么，如何能通过归并的方式得到排序的结果呢？答案是采取一种递归的思想，先分解再合并，我们将原列表分解为一个个的小列表，每个小列表之间进行归并（merge），然后最终小列表合并成大列表，如下图所示，即可得到一个有序列表。****归并排序代码如下： def merge_sort(lis,low,high): if low &lt; high: mid = (low + high) // 2 merge_sort(lis,low,mid) merge_sort(lis,mid+1,high) merge(lis,low,mid,high) return lis 是不是看起来很简单，但是理解起来有些难度，这里采用递归的思想，假如，代码的倒数第二行我们不进行归并，而是对此时的递归进行打印： def merge_sort_view(lis,low,high): if low &lt; high: mid = (low + high) // 2 merge_sort_view(lis,low,mid) merge_sort_view(lis,mid+1,high) print(lis[low:high+1]) 那么我们会得到如下的结果：[11, 8][3, 9][11, 8, 3, 9][7, 1][2, 5][7, 1, 2, 5][11, 8, 3, 9, 7, 1, 2, 5]可以看出，我们在递归过程中，只有当low和high均为 1 时会结束递归，然后当加上归并（merge）函数后，即可进行合并。归并排序的时间复杂度无论什么情况都是O (nlogn)，归并排序是Python内置sort函数的底层之一，内置函数是基于归并排序和插入排序的优化算法，因此，学习Python，了解归并排序是必不可少的。","categories":[{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"堆排序","slug":"heap-sort","date":"2020-10-03T08:47:23.000Z","updated":"2020-10-04T08:56:57.466Z","comments":true,"path":"2020/10/03/heap-sort/","link":"","permalink":"https://runze-li.github.io/2020/10/03/heap-sort/","excerpt":"","text":"学习过堆排序后，今天我们来学习一下堆排序，在学习堆排序之前，我们首先来简单学习一下树的基本知识。树是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。虽然将其称之为树，但它是树根在上，叶子在下的结构，每棵树都具有如下特点： 每个结点有零个或多个子结点 没有父结点的结点称为根结点 每一个非根结点有且只有一个父结点 除了根结点外，每个子结点可以分为多个不相交的子树 现在我们已经大致了解了树的基本形状了，那么在树这个大类中，有着一个特殊的分类—-二叉树，二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个结点。****在二叉树中，有一个更加特殊的分支—-完全二叉树一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。****我们看上图的这个完全二叉树，如果我们将其位置编号如下，会不会发现如下的规律：左子节点 = 2 * 父节点 + 1右子节点 = 2 * 父节点 + 2同理，当我们知道子节点编号是时，同样可以通过 （子节点 - 1）// 2 来得到父节点的位置。现在我们已经大致了解了从树到完全二叉树的一个变换，下面我们来学习一种筛选算法（sift）所谓筛选，就是将已有的二叉树进行重新排列，进而得到大根堆的一个过程。****由上图我们可以看出，大根堆是每一个父节点都会大于子节点的值。所以，简单来说，筛选的方式就是让每一个父节点的子节点都小于它就好。那么具体筛选方式是什么样的呢，现在一起来模拟一下：首先先给到一个完全二叉树：****如上图，我们观察根节点位置是 2 ，那么按照我们的原则，父节点应比其子节点大，因此这个 2 不配在根节点位置，这个时候，我们把 2 拿出二叉树，将其位置空出。****可以看到，现在根节点的位置是空缺的，此时，我们应找到一个数字对根节点进行补全，观察其左右两子节点，发现 9 &gt; 7 ，因此将 9 置于根节点位置，现在， 9 的位置空出，此时，我们考虑是否将 2 放进去，观察原 9 位置的两个子节点 8 与 5 ，均比 2 要大，因此不能将 2 插入，比较两子节点，可发现 8 &gt; 5 ，因此将 8 填入空缺位置，然后 8 的位置空缺，以此类推，6 补空位，最终将 2 置于原 6 的位置即可完成本次筛选 ，最终，对于每一个节点进行sift函数之后即可得到一个大根堆。****其实现代码如下： def sift(lis,root,last): #root为根节点 last为最后一个元素位置 i = root j = 2 * i + 1 #j是左孩子 tmp = lis[root] #储存堆顶 while j &lt;= last: #确定终止循环条件 if j + 1 &lt;= last and lis[j+1] &gt; lis[j]: #比较左右两子节点 j = j + 1 if lis[j] &gt; tmp: lis[i] = lis[j] i = j #将指针指向空位置（父节点） j = 2 * i + 1 else: lis[i] = tmp #如果小于，则root归位 break else: lis[i] = tmp #循环结束后，root归位 可以看出，无论是否完成，最终都要进行root值的归位，那么，其实我们是不是可以在代码当中直接进行简化呢？大家可以在评论区说出你的答案。接下来就是实现堆排序的环节了，我们采取一种倒着取的原则。毋庸置疑，此时的最顶点的 9 是我们刚刚算法派出的最大值。 那现在直接将其取下，作为我们列表中的最大值。****那么接下来该如何取，一定有很多人会想，那我用 8 去补位，实则不然，可以试想一下，8 补了 9 的位置接下来6 补 8，4 补6，可是就没有元素可以补4了，我们现在需要的是一颗完全二叉树。因此，我们这个时候选择最后一个元素 3 作为补位项，然后再通过一次sift算法，将 8 移至顶点，然后将 8 取走，以此类推，最终得到排序好的数列。代码如下： def heap_sort(lis): n = len(lis) for i in range((n-2)//2,-1,-1): #从最后一个节点的父节点开始，从右向左进行筛选 sift(lis,i,n-1) for i in range(n-1,-1,-1): lis[0],lis[i] = lis[i],lis[0] #将最后一个数与第一个数进行交换，重新筛选 sift(lis,0,i - 1) 最终，即可取得排序好的列表，由代码可见，堆排序的时间复杂度为O (nlgn)。其实，即使堆排序和快速排序的时间复杂度都是O (nlgn)，但是在实际操作中，还是快速排序会快一些，堆排序也有它独有的优势，例如说我们要解决的TopK问题，例如说我想要找到某个数列中最大的前K个数，那么我们可以考虑以下几点，第一个是排序后切片，其时间复杂度为O (nlgn)，第二种是利用基本排序方式，例如冒泡排序，其时间复杂度为O (Kn)，如果K &lt; lgn，那么其实第二种方法是快于第一种的，那么第三种方式就是利用堆排序的逐一出数，取前K项。其时间复杂度为O (nlgK)，时间应为最低。但这种方式与堆排序不同，这需要将原二叉树变换为小根堆，在上文我们提及了大根堆，保证每一个父节点都大于其子节点，那么同理，小根堆中，所有父节点也一定小于子节点，代码如下： def sift(lis,root,last): i = root j = 2 * i + 1 #j是左孩子 tmp = lis[root] while j &lt;= last: if j + 1 &lt;= last and lis[j+1] &lt; lis[j]: #注意，这里的小根堆相较于大根堆改成了小于号 j = j + 1 if lis[j] &lt; tmp: #同理，这里也要变为小于号 lis[i] = lis[j] i = j j = 2 * i + 1 else: lis[i] = tmp break else: lis[i] = tmp def topk(lis,k): #选择前K项的函数 heap = lis[0:k] # 1.建堆 for i in range((k-2)//2,-1,-1): sift(heap,i,k-1) #2.遍历 for i in range(k,len(lis)-1): if lis[i] &gt; heap[0]: heap[0] = lis[i] sift(heap,0,k-1) #3.出数 return heap","categories":[{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"快速排序","slug":"Quick-Sort-Partition","date":"2020-10-02T12:52:17.000Z","updated":"2020-10-04T08:56:31.003Z","comments":true,"path":"2020/10/02/Quick-Sort-Partition/","link":"","permalink":"https://runze-li.github.io/2020/10/02/Quick-Sort-Partition/","excerpt":"","text":"在排序算法中，有多种排序方式，例如比较低级的：冒泡排序、选择排序、插入排序。还有相对高级一些的排序方式，比如说这次要说的快速排序。快速排序相较于三种低级排序的优势在于其时间复杂度较小O (nlogn)，其利用了递归的思想，相较于循环结构，大大缩减了其排序时间，那么，快速排序的思想及原理是什么，下面我们来模拟一下。 图一 以上图为例，在介绍快速排序之前，首先想介绍一种算法，分割法（partition），这种算法实现的目的如下： 图二 分割后的结果如下，可以看出，我们以首部数字作为基准，左侧的数字都比该数字要小，右侧的数字都比它要大，那么我们就可以用一种递归的思想进行排序了，例如说，基于上图，我们再对6的左右两边各进行一下partition函数，是不是就可以得到以下结果： 图三 以此类推，是不是就能得到我们想要排序顺序了，但注意，在本次示例中函数的调用出现了一个问题，后续会给大家解释。说了这么多，那什么是分割法（partition），它的原理思想是什么，下面我们一起看一下：所谓分割法，就是取列表中的一个数，其余的数以它为基准，小于基准数的放于左侧，大于基准数的放于右侧 ，可是放置的方法是什么？下面给大家模拟一下：还是以图一的列表为例，首先我们取首部数字为基准数字，如图一所示，我们取 6 作为基准数字，接下来开始进行模拟，假设我们设有两个指针分别置于左右两端（left，right）： 图四 第一步，我们将首部的数字移开，那么该位置将变成一个空位置： 图5 那么这个时候，left指针指向为空，我们需要从right指针处开始寻找，寻找一个比基准值小的数将它置于现在left指针所指向的空位置。right指针处的数字与基准数进行比较，若小于基准数，则将它置于left指针处，若大于，则right指针进行左移，以此类推，以本文数据为例，从最右侧的 7 进行比较，大于基准数则左移，5 小于6，则 5 填补空缺位置： 图六 现在我们将五填补到了left指针所指的空缺位置，但此时我们会发现，right指针处出现了空缺，这个时候我们千万不要将基准数填补至空缺位置，而是采取和之前一样的办法，反过来，从left指针处开始，寻找比基准数要大的数来填补空缺，应从left指针处开始找，小于则left指针右移，大于则将该位置的数进行填补。由图六所示，从 5 开始，找到 8 ，然后将 8 填补到right指针所指位置，同时将left指针所指位置： 图7 以此类推，left指针空缺，再从right指针开始寻找比基准数小的数填补空缺，反之，right指针处空缺，从left指针处寻找比基准数大的数填补空缺。直到left指针与right指针相遇了，那么将基准数填入此时left指针所指位置，即完成了整个分割过程。 图8 由此，就是我们整个分割算法的实现过程了，接下来就是代码的实现了。代码如下： def partition(li,left,right): #划分 tmp = li[left] #设定tmp的值为基准值 while left &lt; right: while left &lt; right and li[right] &gt;= tmp: right = right - 1 li[left] = li[right] #若判断发现小于基准数，则将其填补空缺 while left &lt; right and li[left] &lt;= tmp: left = left + 1 li[right] = li[left] #若判断发现大于基准数，则将其填补空缺 li[left] = tmp #基准值归位 return left #返回右指针位置 接下来就是最终的代码实现了，快速排序是递归的过程，上文我们讲过，在基准数左右两边分别进行partition函数即可，首先基于partition函数的返回值，我们可以确定每一次基准数的最终位置，以此为中心，开始左右两边的递归，最终得到顺序结构。 def _quick_sort(li, left, right): if left &lt; right: mid = partition(li,left,right) #找到每一次的基准数位置 _quick_sort(li,left,mid - 1) #左侧递归 _quick_sort(li,mid+1,right) #右侧递归 def quick_sort(li): #简化快排函数的参数 _quick_sort(li,0,len(li) - 1) 注意： 在这种方式的快排过程中，在取首位为基准数时，若首位本身为这个列表的最大值，那么时间复杂度也会随之提高O（n^2），因此，建议可在选择基准数时进行随机选择，尽可能减少该情况的发生。","categories":[{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"二分搜索","slug":"Binary-Search","date":"2020-10-02T08:11:53.000Z","updated":"2020-10-04T08:54:38.102Z","comments":true,"path":"2020/10/02/Binary-Search/","link":"","permalink":"https://runze-li.github.io/2020/10/02/Binary-Search/","excerpt":"","text":"计算机算法中有两个大类：搜索、排序。在学习查找算法时，我们首先学习的就是二分搜索，下面就是我对二分搜索的一些理解：二分搜索作为一个基础查找算法，适用于列表中查找数据，其时间复杂度为O(log2n)，但是，该方法有着一个弊端就是需要列表内的数据是按顺序由小到大进行排列的，因此，可参照我的其他文章了解排序算法。二分搜索的原理很简单，对一个有序序列进行搜索，在搜索过程中，先确定左右指针（left，right）每次取中间数（mid）的值与目标值（value）进行比较，若mid值大于目标值（value），则将右指针（right）放与mid指针左边即mid - 1处，反之，若mid值小于目标值（value），则将左指针（left）放与mid指针右边即mid + 1处。最终，若判定到mid指针处的值为目标值（value），则返回此时mid指针位置。 代码如下： def binary_search(Inp_list,val): #定义二分搜索函数，两个参数为待搜索列表和目标值 left = 0 #左指针初始位置为0 right = len(Inp_list) - 1 #右指针初始位置为最右侧数位置 while right &gt;= left: mid = (left + right) // 2 #mid指针位置为left与right中间值 if Inp_list[mid] == val: return mid else: if Inp_list[mid] &gt; val: right = mid - 1 else: left = mid + 1 在创建列表时，Python不像C语言那样创建数组，Python中的数组是以列表形式呈现，若手动输入数字需使用Python的列表生成式，代码如下。 list1 = [int(n) for n in input().split()] 最后可进行测试，不要忘记传入参数。注意： 1.在Python中，若两数相除取整数位应为‘ // ’，这点与C语言不同。 2.在Python中是没有指针的，文章中所说只是方便理解，请见谅。","categories":[{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/categories/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/tags/%E6%90%9C%E7%B4%A2/"}]}],"categories":[{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/categories/%E6%90%9C%E7%B4%A2/"},{"name":"数据结构","slug":"数据结构","permalink":"https://runze-li.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"数据结构","slug":"数据结构","permalink":"https://runze-li.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/tags/%E6%8E%92%E5%BA%8F/"}]}