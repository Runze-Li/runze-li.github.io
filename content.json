{"meta":{"title":"RunzeLi's Blog","subtitle":"","description":"一个集百家所长的优质Blog","author":"RunzeLi","url":"https://runze-li.github.io","root":"/"},"pages":[{"title":"404","date":"2020-10-04T11:23:48.575Z","updated":"2020-10-04T11:23:48.568Z","comments":false,"path":"/404.html","permalink":"https://runze-li.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-02T07:20:05.087Z","updated":"2020-10-02T07:20:05.085Z","comments":false,"path":"about/index.html","permalink":"https://runze-li.github.io/about/index.html","excerpt":"","text":"姓名：李润泽 学校： 东北农业大学 主修方向：算法，Python，Java 个人爱好：Linux操作，AI人工智能（Tensor Flow） 联系方式：15045094185"},{"title":"书单","date":"2020-09-30T13:04:17.995Z","updated":"2020-09-30T13:01:41.642Z","comments":false,"path":"books/index.html","permalink":"https://runze-li.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-01T13:04:31.873Z","updated":"2020-09-30T13:01:41.642Z","comments":false,"path":"categories/index.html","permalink":"https://runze-li.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-09-30T13:04:17.996Z","updated":"2020-09-30T13:01:41.642Z","comments":true,"path":"links/index.html","permalink":"https://runze-li.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-09-30T13:04:17.996Z","updated":"2020-09-30T13:01:41.643Z","comments":false,"path":"repository/index.html","permalink":"https://runze-li.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-09-30T13:04:17.996Z","updated":"2020-09-30T13:01:41.643Z","comments":false,"path":"tags/index.html","permalink":"https://runze-li.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"三种基本排序","slug":"low-sort","date":"2020-10-05T13:33:00.000Z","updated":"2020-10-05T13:37:12.365Z","comments":true,"path":"2020/10/05/low-sort/","link":"","permalink":"https://runze-li.github.io/2020/10/05/low-sort/","excerpt":"","text":"以下是三种基础排序的Python实现代码：冒泡排序： def bubble_sort(li): #冒泡排序 for i in range(len(li)-1): for j in range(len(li)-i-1): if li[j] &gt; li[j+1]: li[j],li[j+1] = li[j+1],li[j] 选择排序： def select_sort(li): #选择排序 for i in range(len(li)-1): min_loc = i for j in range (i+1,len(li)): if li[j] &lt; li[min_loc]: min_loc = j li[i],li[min_loc] = li[min_loc],li[i] 插入排序： def insert_sort(li): #插入排序 for i in range(1,len(li)): tmp = li[i] j = i - 1 while j &gt;= 0 and li[j] &gt; tmp: li[j+1] = li[j] j = j - 1 li[j+1] = tmp","categories":[{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"归并排序","slug":"merge-sort","date":"2020-10-04T06:58:21.000Z","updated":"2020-10-04T08:56:46.414Z","comments":true,"path":"2020/10/04/merge-sort/","link":"","permalink":"https://runze-li.github.io/2020/10/04/merge-sort/","excerpt":"","text":"这次要和大家聊一聊归并排序，那么什么是归并排序呢，首先给大家举一个简单的例子：****如上图，我们得到一个列表，其实这个列表有一个规律，那就是如果我们从中间截断，左右两边的小列表其实是有序的，在学习数据结构时，我们学习过一个经典例题，合并两个有序数组，那么这个时候是不是可以像合并数组那样合并这两个有序数列。****如上图，我们把这个列表分为两段，标记好起始元素位置（low）和终止元素位置（high）以及两地址的中间地址（mid），其实，我们已经把整个列表以mid为中心，分成两个小列表了，这个时候就可以利用归并（merge）的思想，首先我们取到两个指针，i，j，这两个指针分别指向两个小列表的第一个元素，这个时候，我们比较i位置的元素大小和j位置的元素大小，我们假设这个列表为lis,那么lis[i] &lt; lis[j]的话，是不是就可以断定，lis[i]此时的元素就是最小的元素了，反之，要是lis[j] &lt; lis[i]，那么lis[j]就是整个列表中最小的元素，这个时候我们就可以把这个最小的元素取出放于一个新列表的首位，我们假设这个新列表是ltmp，这个时候，按照我们的例子，1 就被取下放置于我们的新列表中了，同时，j指针的位置要向后移动一位。****以此类推，比较i位置与j位置的大小关系，然后把每一次的最小值暂存到新列表（ltmp）中，不要忘记指针随着原位置数的取出而后移。****那么什么时候终止呢？有两种情况，第一种是 i 指针大于mid位置的时候，第二种是 j 指针大于high位置的时候。终止后会也会发现两种情况，要么是左边的小列表数字有剩余，要么是右边的小列表数字有剩余，这个时候，我们知道，左右两边的列表其实是有序的，那么本身不需要再进行排列了，直接放到新列表（ltmp）的末尾就好，最后，我们只要把新列表（ltmp）再归还给原列表（lis）就完成了一次归并（merge）。代码如下： def merge(lis,low,mid,high): i = low j = mid + 1 ltmp = [] while i &lt;= mid and j &lt;= high: if lis[i] &lt; lis[j]: ltmp.append(lis[i]) i = i + 1 if lis[j] &lt; lis[i]: ltmp.append(lis[j]) j = j + 1 while i &lt;= mid: ltmp.append(lis[i]) i = i + 1 while j &lt;= high: ltmp.append(lis[j]) j = j + 1 lis[low:high+1] = ltmp 接下来就是整个归并排序的核心了，在实际排序过程中，我们几乎很少能遇到上文这种理想的情况，我们得到的列表大多是无序的。那么，如何能通过归并的方式得到排序的结果呢？答案是采取一种递归的思想，先分解再合并，我们将原列表分解为一个个的小列表，每个小列表之间进行归并（merge），然后最终小列表合并成大列表，如下图所示，即可得到一个有序列表。****归并排序代码如下： def merge_sort(lis,low,high): if low &lt; high: mid = (low + high) // 2 merge_sort(lis,low,mid) merge_sort(lis,mid+1,high) merge(lis,low,mid,high) return lis 是不是看起来很简单，但是理解起来有些难度，这里采用递归的思想，假如，代码的倒数第二行我们不进行归并，而是对此时的递归进行打印： def merge_sort_view(lis,low,high): if low &lt; high: mid = (low + high) // 2 merge_sort_view(lis,low,mid) merge_sort_view(lis,mid+1,high) print(lis[low:high+1]) 那么我们会得到如下的结果：[11, 8][3, 9][11, 8, 3, 9][7, 1][2, 5][7, 1, 2, 5][11, 8, 3, 9, 7, 1, 2, 5]可以看出，我们在递归过程中，只有当low和high均为 1 时会结束递归，然后当加上归并（merge）函数后，即可进行合并。归并排序的时间复杂度无论什么情况都是O (nlogn)，归并排序是Python内置sort函数的底层之一，内置函数是基于归并排序和插入排序的优化算法，因此，学习Python，了解归并排序是必不可少的。","categories":[{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"堆排序","slug":"heap-sort","date":"2020-10-03T08:47:23.000Z","updated":"2020-10-04T08:56:57.466Z","comments":true,"path":"2020/10/03/heap-sort/","link":"","permalink":"https://runze-li.github.io/2020/10/03/heap-sort/","excerpt":"","text":"学习过堆排序后，今天我们来学习一下堆排序，在学习堆排序之前，我们首先来简单学习一下树的基本知识。树是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。虽然将其称之为树，但它是树根在上，叶子在下的结构，每棵树都具有如下特点： 每个结点有零个或多个子结点 没有父结点的结点称为根结点 每一个非根结点有且只有一个父结点 除了根结点外，每个子结点可以分为多个不相交的子树 现在我们已经大致了解了树的基本形状了，那么在树这个大类中，有着一个特殊的分类—-二叉树，二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个结点。****在二叉树中，有一个更加特殊的分支—-完全二叉树一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。****我们看上图的这个完全二叉树，如果我们将其位置编号如下，会不会发现如下的规律：左子节点 = 2 * 父节点 + 1右子节点 = 2 * 父节点 + 2同理，当我们知道子节点编号是时，同样可以通过 （子节点 - 1）// 2 来得到父节点的位置。现在我们已经大致了解了从树到完全二叉树的一个变换，下面我们来学习一种筛选算法（sift）所谓筛选，就是将已有的二叉树进行重新排列，进而得到大根堆的一个过程。****由上图我们可以看出，大根堆是每一个父节点都会大于子节点的值。所以，简单来说，筛选的方式就是让每一个父节点的子节点都小于它就好。那么具体筛选方式是什么样的呢，现在一起来模拟一下：首先先给到一个完全二叉树：****如上图，我们观察根节点位置是 2 ，那么按照我们的原则，父节点应比其子节点大，因此这个 2 不配在根节点位置，这个时候，我们把 2 拿出二叉树，将其位置空出。****可以看到，现在根节点的位置是空缺的，此时，我们应找到一个数字对根节点进行补全，观察其左右两子节点，发现 9 &gt; 7 ，因此将 9 置于根节点位置，现在， 9 的位置空出，此时，我们考虑是否将 2 放进去，观察原 9 位置的两个子节点 8 与 5 ，均比 2 要大，因此不能将 2 插入，比较两子节点，可发现 8 &gt; 5 ，因此将 8 填入空缺位置，然后 8 的位置空缺，以此类推，6 补空位，最终将 2 置于原 6 的位置即可完成本次筛选 ，最终，对于每一个节点进行sift函数之后即可得到一个大根堆。****其实现代码如下： def sift(lis,root,last): #root为根节点 last为最后一个元素位置 i = root j = 2 * i + 1 #j是左孩子 tmp = lis[root] #储存堆顶 while j &lt;= last: #确定终止循环条件 if j + 1 &lt;= last and lis[j+1] &gt; lis[j]: #比较左右两子节点 j = j + 1 if lis[j] &gt; tmp: lis[i] = lis[j] i = j #将指针指向空位置（父节点） j = 2 * i + 1 else: lis[i] = tmp #如果小于，则root归位 break else: lis[i] = tmp #循环结束后，root归位 可以看出，无论是否完成，最终都要进行root值的归位，那么，其实我们是不是可以在代码当中直接进行简化呢？大家可以在评论区说出你的答案。接下来就是实现堆排序的环节了，我们采取一种倒着取的原则。毋庸置疑，此时的最顶点的 9 是我们刚刚算法派出的最大值。 那现在直接将其取下，作为我们列表中的最大值。****那么接下来该如何取，一定有很多人会想，那我用 8 去补位，实则不然，可以试想一下，8 补了 9 的位置接下来6 补 8，4 补6，可是就没有元素可以补4了，我们现在需要的是一颗完全二叉树。因此，我们这个时候选择最后一个元素 3 作为补位项，然后再通过一次sift算法，将 8 移至顶点，然后将 8 取走，以此类推，最终得到排序好的数列。代码如下： def heap_sort(lis): n = len(lis) for i in range((n-2)//2,-1,-1): #从最后一个节点的父节点开始，从右向左进行筛选 sift(lis,i,n-1) for i in range(n-1,-1,-1): lis[0],lis[i] = lis[i],lis[0] #将最后一个数与第一个数进行交换，重新筛选 sift(lis,0,i - 1) 最终，即可取得排序好的列表，由代码可见，堆排序的时间复杂度为O (nlgn)。其实，即使堆排序和快速排序的时间复杂度都是O (nlgn)，但是在实际操作中，还是快速排序会快一些，堆排序也有它独有的优势，例如说我们要解决的TopK问题，例如说我想要找到某个数列中最大的前K个数，那么我们可以考虑以下几点，第一个是排序后切片，其时间复杂度为O (nlgn)，第二种是利用基本排序方式，例如冒泡排序，其时间复杂度为O (Kn)，如果K &lt; lgn，那么其实第二种方法是快于第一种的，那么第三种方式就是利用堆排序的逐一出数，取前K项。其时间复杂度为O (nlgK)，时间应为最低。但这种方式与堆排序不同，这需要将原二叉树变换为小根堆，在上文我们提及了大根堆，保证每一个父节点都大于其子节点，那么同理，小根堆中，所有父节点也一定小于子节点，代码如下： def sift(lis,root,last): i = root j = 2 * i + 1 #j是左孩子 tmp = lis[root] while j &lt;= last: if j + 1 &lt;= last and lis[j+1] &lt; lis[j]: #注意，这里的小根堆相较于大根堆改成了小于号 j = j + 1 if lis[j] &lt; tmp: #同理，这里也要变为小于号 lis[i] = lis[j] i = j j = 2 * i + 1 else: lis[i] = tmp break else: lis[i] = tmp def topk(lis,k): #选择前K项的函数 heap = lis[0:k] # 1.建堆 for i in range((k-2)//2,-1,-1): sift(heap,i,k-1) #2.遍历 for i in range(k,len(lis)-1): if lis[i] &gt; heap[0]: heap[0] = lis[i] sift(heap,0,k-1) #3.出数 return heap","categories":[{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"快速排序","slug":"Quick-Sort-Partition","date":"2020-10-02T12:52:17.000Z","updated":"2020-10-04T08:56:31.003Z","comments":true,"path":"2020/10/02/Quick-Sort-Partition/","link":"","permalink":"https://runze-li.github.io/2020/10/02/Quick-Sort-Partition/","excerpt":"","text":"在排序算法中，有多种排序方式，例如比较低级的：冒泡排序、选择排序、插入排序。还有相对高级一些的排序方式，比如说这次要说的快速排序。快速排序相较于三种低级排序的优势在于其时间复杂度较小O (nlogn)，其利用了递归的思想，相较于循环结构，大大缩减了其排序时间，那么，快速排序的思想及原理是什么，下面我们来模拟一下。 图一 以上图为例，在介绍快速排序之前，首先想介绍一种算法，分割法（partition），这种算法实现的目的如下： 图二 分割后的结果如下，可以看出，我们以首部数字作为基准，左侧的数字都比该数字要小，右侧的数字都比它要大，那么我们就可以用一种递归的思想进行排序了，例如说，基于上图，我们再对6的左右两边各进行一下partition函数，是不是就可以得到以下结果： 图三 以此类推，是不是就能得到我们想要排序顺序了，但注意，在本次示例中函数的调用出现了一个问题，后续会给大家解释。说了这么多，那什么是分割法（partition），它的原理思想是什么，下面我们一起看一下：所谓分割法，就是取列表中的一个数，其余的数以它为基准，小于基准数的放于左侧，大于基准数的放于右侧 ，可是放置的方法是什么？下面给大家模拟一下：还是以图一的列表为例，首先我们取首部数字为基准数字，如图一所示，我们取 6 作为基准数字，接下来开始进行模拟，假设我们设有两个指针分别置于左右两端（left，right）： 图四 第一步，我们将首部的数字移开，那么该位置将变成一个空位置： 图5 那么这个时候，left指针指向为空，我们需要从right指针处开始寻找，寻找一个比基准值小的数将它置于现在left指针所指向的空位置。right指针处的数字与基准数进行比较，若小于基准数，则将它置于left指针处，若大于，则right指针进行左移，以此类推，以本文数据为例，从最右侧的 7 进行比较，大于基准数则左移，5 小于6，则 5 填补空缺位置： 图六 现在我们将五填补到了left指针所指的空缺位置，但此时我们会发现，right指针处出现了空缺，这个时候我们千万不要将基准数填补至空缺位置，而是采取和之前一样的办法，反过来，从left指针处开始，寻找比基准数要大的数来填补空缺，应从left指针处开始找，小于则left指针右移，大于则将该位置的数进行填补。由图六所示，从 5 开始，找到 8 ，然后将 8 填补到right指针所指位置，同时将left指针所指位置： 图7 以此类推，left指针空缺，再从right指针开始寻找比基准数小的数填补空缺，反之，right指针处空缺，从left指针处寻找比基准数大的数填补空缺。直到left指针与right指针相遇了，那么将基准数填入此时left指针所指位置，即完成了整个分割过程。 图8 由此，就是我们整个分割算法的实现过程了，接下来就是代码的实现了。代码如下： def partition(li,left,right): #划分 tmp = li[left] #设定tmp的值为基准值 while left &lt; right: while left &lt; right and li[right] &gt;= tmp: right = right - 1 li[left] = li[right] #若判断发现小于基准数，则将其填补空缺 while left &lt; right and li[left] &lt;= tmp: left = left + 1 li[right] = li[left] #若判断发现大于基准数，则将其填补空缺 li[left] = tmp #基准值归位 return left #返回右指针位置 接下来就是最终的代码实现了，快速排序是递归的过程，上文我们讲过，在基准数左右两边分别进行partition函数即可，首先基于partition函数的返回值，我们可以确定每一次基准数的最终位置，以此为中心，开始左右两边的递归，最终得到顺序结构。 def _quick_sort(li, left, right): if left &lt; right: mid = partition(li,left,right) #找到每一次的基准数位置 _quick_sort(li,left,mid - 1) #左侧递归 _quick_sort(li,mid+1,right) #右侧递归 def quick_sort(li): #简化快排函数的参数 _quick_sort(li,0,len(li) - 1) 注意： 在这种方式的快排过程中，在取首位为基准数时，若首位本身为这个列表的最大值，那么时间复杂度也会随之提高O（n^2），因此，建议可在选择基准数时进行随机选择，尽可能减少该情况的发生。","categories":[{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"二分搜索","slug":"Binary-Search","date":"2020-10-02T08:11:53.000Z","updated":"2020-10-04T08:54:38.102Z","comments":true,"path":"2020/10/02/Binary-Search/","link":"","permalink":"https://runze-li.github.io/2020/10/02/Binary-Search/","excerpt":"","text":"计算机算法中有两个大类：搜索、排序。在学习查找算法时，我们首先学习的就是二分搜索，下面就是我对二分搜索的一些理解：二分搜索作为一个基础查找算法，适用于列表中查找数据，其时间复杂度为O(log2n)，但是，该方法有着一个弊端就是需要列表内的数据是按顺序由小到大进行排列的，因此，可参照我的其他文章了解排序算法。二分搜索的原理很简单，对一个有序序列进行搜索，在搜索过程中，先确定左右指针（left，right）每次取中间数（mid）的值与目标值（value）进行比较，若mid值大于目标值（value），则将右指针（right）放与mid指针左边即mid - 1处，反之，若mid值小于目标值（value），则将左指针（left）放与mid指针右边即mid + 1处。最终，若判定到mid指针处的值为目标值（value），则返回此时mid指针位置。 代码如下： def binary_search(Inp_list,val): #定义二分搜索函数，两个参数为待搜索列表和目标值 left = 0 #左指针初始位置为0 right = len(Inp_list) - 1 #右指针初始位置为最右侧数位置 while right &gt;= left: mid = (left + right) // 2 #mid指针位置为left与right中间值 if Inp_list[mid] == val: return mid else: if Inp_list[mid] &gt; val: right = mid - 1 else: left = mid + 1 在创建列表时，Python不像C语言那样创建数组，Python中的数组是以列表形式呈现，若手动输入数字需使用Python的列表生成式，代码如下。 list1 = [int(n) for n in input().split()] 最后可进行测试，不要忘记传入参数。注意： 1.在Python中，若两数相除取整数位应为‘ // ’，这点与C语言不同。 2.在Python中是没有指针的，文章中所说只是方便理解，请见谅。","categories":[{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/categories/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/tags/%E6%90%9C%E7%B4%A2/"}]}],"categories":[{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/categories/%E6%8E%92%E5%BA%8F/"},{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/categories/%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://runze-li.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://runze-li.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://runze-li.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"搜索","slug":"搜索","permalink":"https://runze-li.github.io/tags/%E6%90%9C%E7%B4%A2/"}]}